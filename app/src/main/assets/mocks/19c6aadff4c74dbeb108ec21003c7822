{"url":"https://api.github.com/gists/19c6aadff4c74dbeb108ec21003c7822","forks_url":"https://api.github.com/gists/19c6aadff4c74dbeb108ec21003c7822/forks","commits_url":"https://api.github.com/gists/19c6aadff4c74dbeb108ec21003c7822/commits","id":"19c6aadff4c74dbeb108ec21003c7822","git_pull_url":"https://gist.github.com/19c6aadff4c74dbeb108ec21003c7822.git","git_push_url":"https://gist.github.com/19c6aadff4c74dbeb108ec21003c7822.git","html_url":"https://gist.github.com/19c6aadff4c74dbeb108ec21003c7822","files":{"AbstractMockedInterceptor.java":{"filename":"AbstractMockedInterceptor.java","type":"text/plain","language":"Java","raw_url":"https://gist.githubusercontent.com/anonymous/19c6aadff4c74dbeb108ec21003c7822/raw/53e9bcafdaaf98d3b7384651991b2d61b67f8664/AbstractMockedInterceptor.java","size":21039,"truncated":false,"content":"package com.example.chriskoeberle.githubexample.home.endpoint;\n\nimport android.content.Context;\nimport android.content.res.AssetManager;\nimport android.text.TextUtils;\n\nimport org.joda.time.DateTime;\nimport org.joda.time.LocalDate;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.io.Writer;\nimport java.net.HttpURLConnection;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport okhttp3.HttpUrl;\nimport okhttp3.Interceptor;\nimport okhttp3.MediaType;\nimport okhttp3.Protocol;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport timber.log.Timber;\n\npublic abstract class AbstractMockedInterceptor implements Interceptor {\n    private static final String OFFSET_PARAMETER = \"offset\";\n    private static final String INDEX_PARAMETER = \"index\";\n    private static final String NAME_PARAMETER = \"name\";\n    private static final Pattern DATETIME = Pattern.compile(\"%DATETIME[^%]*%\");\n    private static final Pattern DATE = Pattern.compile(\"%DATE[^%]*%\");\n    private static final Pattern PARAMETER = Pattern.compile(\"%PARAMETER[^%]*%\");\n\n    private final Context mContext;\n    protected final ArrayList<ResponseSpec> mResponseList = new ArrayList<>();\n    private ArrayList<StringSubstitutor> mSubstitutorList;\n\n    public static class ResponseSpec {\n        private final String mFilename;\n        private int mCode;\n        private String mMessage;\n        private final String mPattern;\n        private String mMethod;\n        private Map<String, String> mQueryParameters;\n        private String mBody;\n        private Set<String> mBodyContains;\n\n        protected ResponseSpec(String pattern, String filename) {\n            this.mPattern = pattern;\n            this.mFilename = filename;\n            this.mCode = HttpURLConnection.HTTP_OK;\n            this.mMessage = \"OK\";\n            this.mQueryParameters = new HashMap<>();\n            this.mMethod = \"GET\";\n        }\n\n        public ResponseSpec setCode(int code) {\n            mCode = code;\n            return this;\n        }\n\n        public ResponseSpec setMethod(String method) {\n            mMethod = method;\n            return this;\n        }\n\n        public ResponseSpec addQueryParameter(String keyPattern, String valuePattern) {\n            this.mQueryParameters.put(keyPattern, valuePattern);\n            return this;\n        }\n\n        public ResponseSpec addBody(String body) {\n            if (\"GET\".equalsIgnoreCase(this.mMethod)) {\n                this.mMethod = \"POST\";\n            }\n            this.mBody = body;\n            return this;\n        }\n\n        public ResponseSpec addBodyContains(String bodyBit) {\n            if (\"GET\".equalsIgnoreCase(this.mMethod)) {\n                this.mMethod = \"POST\";\n            }\n            if (mBodyContains == null) {\n                mBodyContains = new HashSet<>();\n            }\n            mBodyContains.add(bodyBit);\n            return this;\n        }\n\n        public boolean matches(HttpUrl url, String method, String body) {\n            if (!url.encodedPath().matches(mPattern)) {\n                return false;\n            }\n            if (!mMethod.equalsIgnoreCase(method)) {\n                return false;\n            }\n            if (mMethod.equalsIgnoreCase(\"POST\") && !TextUtils.isEmpty(mBody) && !mBody.equalsIgnoreCase(body)) {\n                return false;\n            }\n            if (mMethod.equalsIgnoreCase(\"POST\") && mBodyContains != null) {\n                for (String contains : mBodyContains) {\n                    if (!body.contains(contains)) {\n                        return false;\n                    }\n                }\n            }\n            for (Map.Entry<String, String> kvp : mQueryParameters.entrySet()) {\n                boolean foundKey = false;\n                boolean foundValue = false;\n                for (String key : url.queryParameterNames()) {\n                    if (key.matches(kvp.getKey())) {\n                        foundKey = true;\n                        String value = url.queryParameter(key);\n                        if (value != null && value.matches(kvp.getValue())) {\n                            foundValue = true;\n                        }\n                        if (value == null && (kvp.getValue() == null || kvp.getValue() == \"\" || kvp.getValue().equalsIgnoreCase(\"null\"))) {\n                            foundValue = true;\n                        }\n                    }\n                }\n                if (!foundKey || !foundValue) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public ResponseSpec setMessage(String message) {\n            this.mMessage = message;\n            return this;\n        }\n    }\n\n    public AbstractMockedApiInterceptor(Context context) {\n        if (context != null) {\n            mContext = context.getApplicationContext();\n        } else {\n            mContext = null;\n        }\n        addSubstitutors();\n    }\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        ResponseSpec mockFound = null;\n        for (ResponseSpec spec : mResponseList) {\n            if (spec.matches(request.url(), request.method(), stringifyRequestBody(request))) {\n                mockFound = spec;\n                Response.Builder builder = new Response.Builder();\n                String bodyString = resolveAsset(spec.mFilename);\n                bodyString = substituteStrings(bodyString, request);\n                if(bodyString != null) {\n                    ResponseBody body = ResponseBody.create(MediaType.parse(getMockedMediaType()), bodyString);\n                    builder = builder.body(body).request(request).protocol(Protocol.HTTP_1_1).code(spec.mCode).message(spec.mMessage);\n                }\n                if (!ignoreExistingMocks()) {\n                    noteThatThisFileWasUsed(spec.mFilename);\n                    return builder.build();\n                }\n\n            }\n        }\n        Response response = chain.proceed(request);\n        if (!request.url().encodedPath().endsWith(\"png\")\n                && !request.url().encodedPath().endsWith(\"jpg\")) {\n            response = memorializeRequest(request, response, mockFound);\n        }\n        return response;\n    }\n\n    protected boolean ignoreExistingMocks() {\n        return false;\n    }\n\n    protected String getMockedMediaType() {\n        return \"json\";\n    }\n\n    private String substituteStrings(String bodyString, Request request) {\n        // Because each match can get replaced with something different, we have to reset the matcher after every replacement.\n        // This way of doing things happens to enforce this in a non-obvious way, because we create a new matcher every time.\n        for (StringSubstitutor substitutor : mSubstitutorList) {\n            while (substitutor.matchesFound(bodyString)) {\n                bodyString = substitutor.replaceOneString(bodyString, request);\n            }\n        }\n        return bodyString;\n    }\n\n    private static Map<String, String> getQueryFromUri(String match) {\n        if (!match.contains(\"?\")) {\n            return new HashMap<>();\n        }\n        String queryString= match.substring(match.indexOf(\"?\")+1, match.length()-1);\n        Map<String, String> query = queryStringToNamesAndValues(queryString);\n        return query;\n    }\n\n    private Response memorializeRequest(Request request, Response response, ResponseSpec mockFound) {\n        Response.Builder newResponseBuilder = response.newBuilder();\n        try {\n            String responseString = response.body().string();\n            List<String> segments = request.url().encodedPathSegments();\n            String endpointName = segments.get(segments.size() - 1);\n            String requestSpecString = \"mResponseList.add(new ResponseSpec(\\\"\"+request.url().encodedPath()+\"\\\", \\\"::REPLACE_ME::\\\")\";\n            if (response.code() != HttpURLConnection.HTTP_OK) {\n                requestSpecString += \".setCode(\"+response.code()+\")\";\n                endpointName += \"-\"+response.code();\n            }\n            if (!TextUtils.isEmpty(response.message()) && !response.message().equalsIgnoreCase(\"OK\")) {\n                requestSpecString += \".setMessage(\\\"\"+response.message()+\"\\\")\";\n            }\n            if (!request.method().equalsIgnoreCase(\"GET\")) {\n                requestSpecString += \".setMethod(\\\"\"+request.method()+\"\\\")\";\n                endpointName += \"-\"+request.method();\n            }\n            if (request.url().querySize()>0) {\n                for (String key : request.url().queryParameterNames()) {\n                    requestSpecString += \".addQueryParameter(\\\"\"+key.replace(\"[\", \"\\\\\\\\[\").replace(\"]\", \"\\\\\\\\]\")+\"\\\", \\\"\"+request.url().queryParameter(key)+\"\\\")\";\n                }\n            }\n            String body = stringifyRequestBody(request);\n            if (body != null) {\n                requestSpecString += \".addBody(\\\"\"+body.replace(\"\\\"\", \"\\\\\\\"\").replace(\"\\\\u003d\", \"\\\\\\\\u003d\")+\"\\\")\";\n                endpointName += \"-\"+body.hashCode();\n            }\n            requestSpecString += \");\";\n            if (endpointName.length()>100) {\n                endpointName = \"\"+endpointName.hashCode();\n            }\n            endpointName = getUniqueName(endpointName);\n            requestSpecString = requestSpecString.replace(\"::REPLACE_ME::\", endpointName);\n            if (mockFound != null) {\n                requestSpecString += \" // duplicate of existing mock \"+mockFound.mPattern;\n                if (!TextUtils.isEmpty(mockFound.mBody)) {\n                    requestSpecString += \" with body \"+mockFound.mBody;\n                }\n            }\n            requestSpecString += \"\\n\";\n            writeToFile(requestSpecString, responseString, endpointName);\n            newResponseBuilder.body(ResponseBody.create(response.body().contentType(), responseString));\n        } catch (IOException e) {\n            Timber.e(\"Unable to save request to \"+request.url().toString()+\" : \", e);\n        }\n        return newResponseBuilder.build();\n    }\n\n    private String getUniqueName(String endpointName) {\n        List<Integer> usedNumbers = new ArrayList<>();\n        Pattern pattern = Pattern.compile(endpointName + \"-\\\\d*$\");\n        List<String> possibleCollisions = new ArrayList<>();\n        for (ResponseSpec spec : mResponseList) {\n            possibleCollisions.add(spec.mFilename);\n        }\n        for (String filename : getFilesDir().list()) {\n            possibleCollisions.add(filename);\n        }\n        boolean collides = false;\n        for (String string : possibleCollisions) {\n            if (string.equalsIgnoreCase(endpointName)) {\n                collides = true;\n            } else {\n                if (pattern.matcher(string).find()) {\n                    String suffix = string.substring(string.lastIndexOf(\"-\")+1);\n                    Integer number = Integer.parseInt(suffix);\n                    usedNumbers.add(number);\n                }\n            }\n        }\n        if (collides) {\n            Integer i = 1;\n            while (usedNumbers.contains(i)) {\n                i = i + 1;\n            }\n            endpointName = endpointName + \"-\" + i;\n        }\n        return endpointName;\n    }\n\n    private static String stringifyRequestBody(Request request) {\n        try {\n            final Request copy = request.newBuilder().build();\n            if (copy.body() == null) {\n                return null;\n            }\n            final okio.Buffer buffer = new okio.Buffer();\n            copy.body().writeTo(buffer);\n            return buffer.readUtf8();\n        } catch (final IOException e) {\n            return \"did not work\";\n        }\n    }\n\n    private void noteThatThisFileWasUsed(String filename) throws IOException {\n        File dir = getFilesDir();\n        if(dir == null) {\n            Timber.e(\"Unable to access external files directory\");\n            return;\n        }\n        String filesDir = dir.getAbsolutePath();\n        File specs = new File(filesDir + \"/MOCKSused\");\n        if (!specs.exists()) {\n            if (!specs.createNewFile()) {\n                Timber.e(\"Could not create file \"+specs.getAbsolutePath());\n            }\n        }\n        FileWriter write = new FileWriter(specs, true);\n        BufferedWriter writer = new BufferedWriter(write);\n        writer.write(filename+\"\\n\");\n        writer.close();\n    }\n\n    private void writeToFile(String requestSpecString, String responseString, String endpoint) throws IOException {\n        File dir = getFilesDir();\n        if(dir == null) {\n            Timber.e(\"Unable to access external files directory\");\n            return;\n        }\n        String filesDir = dir.getAbsolutePath();\n        File specs = new File(filesDir + \"/MOCKSspecs\");\n        if (!specs.exists()) {\n            if (!specs.createNewFile()) {\n                Timber.e(\"Could not create file \"+specs.getAbsolutePath());\n            }\n        }\n        FileWriter write = new FileWriter(specs, true);\n        BufferedWriter writer = new BufferedWriter(write);\n        writer.write(requestSpecString);\n        writer.close();\n        write = new FileWriter(filesDir + \"/\" + endpoint);\n        writer = new BufferedWriter(write);\n        writer.write(responseString);\n        writer.close();\n    }\n\n    private File getFilesDir() {\n        File dir = null;\n        if (mContext != null) {\n            dir = mContext.getExternalFilesDir(null);\n        } else {\n            dir = new File(\"mocks\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n        }\n        return dir;\n    }\n\n    private String resolveAsset(String filename) {\n        if (mContext != null) {\n            return getAssetAsString(mContext, filename);\n        } else {\n            try {\n                return readFromAsset(filename);\n            } catch (IOException e) {\n                Timber.e(e, \"Error reading from asset - this should only be called in tests.\");\n            }\n        }\n        return null;\n    }\n\n    public static String getAssetAsString(Context context, String assetName) {\n        if (context == null) {\n            return null;\n        }\n\n        InputStream is = new InputStream() {\n            @Override\n            public int read() throws IOException {\n                return 0;\n            }\n        };\n        Writer writer = new StringWriter();\n        char[] buffer = new char[1024];\n        Reader reader=null;\n\n        try {\n            AssetManager assets = context.getAssets();\n            is = assets.open(assetName);\n\n            reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n            int n;\n            while ((n = reader.read(buffer)) != -1) {\n                writer.write(buffer, 0, n);\n            }\n        } catch (UnsupportedEncodingException e) {\n            Timber.e(e, \"Unsupported encoding of asset: \");\n            return null;\n        } catch (IOException e) {\n            Timber.e(e, \"IOException when retrieving asset: \");\n            return null;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    Timber.e(e, \"IOException when closing stream: \");\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    Timber.e(e, \"IOException when closing reader: \");\n                }\n            }\n        }\n\n        return writer.toString();\n    }\n\n    protected String readFromAsset(String filename) throws IOException {\n        InputStream stream = getClass().getClassLoader().getResourceAsStream(filename);\n        if (stream==null){\n            System.out.println(\"No stream for \"+filename+\"!\");\n        }\n        ByteArrayOutputStream result = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = stream.read(buffer)) != -1) {\n            result.write(buffer, 0, length);\n        }\n        return result.toString(\"UTF-8\");\n    }\n\n    static Map<String, String> queryStringToNamesAndValues(String encodedQuery) {\n        Map<String, String> result = new HashMap<>();\n        for (int pos = 0; pos <= encodedQuery.length(); ) {\n            int ampersandOffset = encodedQuery.indexOf('&', pos);\n            if (ampersandOffset == -1) ampersandOffset = encodedQuery.length();\n\n            int equalsOffset = encodedQuery.indexOf('=', pos);\n            if (equalsOffset == -1 || equalsOffset > ampersandOffset) {\n                result.put(encodedQuery.substring(pos, ampersandOffset), null);\n            } else {\n                result.put(encodedQuery.substring(pos, equalsOffset), (encodedQuery.substring(equalsOffset + 1, ampersandOffset)));\n            }\n            pos = ampersandOffset + 1;\n        }\n        return result;\n    }\n\n    private static interface StringSubstitutor {\n        String replaceOneString(String body, Request request);\n        boolean matchesFound(String body);\n    }\n\n    private static class ParameterSubstitutor implements StringSubstitutor {\n        @Override\n        public String replaceOneString(String body, Request request) {\n            Matcher parameterMatcher = PARAMETER.matcher(body);\n            parameterMatcher.find();\n            String match = parameterMatcher.group();\n            String parameter = \"\";\n            Map<String, String> query = getQueryFromUri(match);\n            try {\n                if (query.containsKey(INDEX_PARAMETER)) {\n                    int index = Integer.parseInt(query.get(INDEX_PARAMETER));\n                    if (index < request.url().querySize()) {\n                        parameter = request.url().queryParameterValue(index);\n                    }\n                } else if (query.containsKey(NAME_PARAMETER)) {\n                    String name = query.get(NAME_PARAMETER);\n                    if (request.url().queryParameterNames().contains(name)) {\n                        parameter = request.url().queryParameterValues(name).get(0);\n                    }\n                }\n                body = parameterMatcher.replaceFirst(parameter);\n            } catch (Exception e) {\n                Timber.e(e, \"You did something wrong when setting up your parameter interceptor. \");\n            }\n            return body;\n        }\n\n        @Override\n        public boolean matchesFound(String body) {\n            Matcher parameterMatcher = PARAMETER.matcher(body);\n            return parameterMatcher.find();\n        }\n    }\n\n    private static class DateSubstitutor implements StringSubstitutor {\n        @Override\n        public String replaceOneString(String body, Request request) {\n            Matcher dateMatcher = DATE.matcher(body);\n            dateMatcher.find();\n            String match = dateMatcher.group();\n            Map<String, String> query = getQueryFromUri(match);\n            LocalDate date = new LocalDate();\n            if(query.containsKey(OFFSET_PARAMETER)) {\n                date = date.plusDays(Integer.parseInt(query.get(OFFSET_PARAMETER)));\n            }\n            body = dateMatcher.replaceFirst(date.toString());\n            return body;\n        }\n\n        @Override\n        public boolean matchesFound(String body) {\n            Matcher dateMatcher = DATE.matcher(body);\n            return dateMatcher.find();\n        }\n    }\n\n    private static class DateTimeSubstitutor implements StringSubstitutor {\n        @Override\n        public String replaceOneString(String body, Request request) {\n            Matcher dateTimeMatcher = DATETIME.matcher(body);\n            dateTimeMatcher.find();\n\n            String match = dateTimeMatcher.group();\n            Map<String, String> query = getQueryFromUri(match);\n            DateTime time = new DateTime();\n            if(query.containsKey(OFFSET_PARAMETER)) {\n                time = time.plusDays(Integer.parseInt(query.get(OFFSET_PARAMETER)));\n            }\n            String timeString = time.toString();\n            body = dateTimeMatcher.replaceFirst(timeString);\n            return body;\n        }\n\n        @Override\n        public boolean matchesFound(String body) {\n            Matcher dateTimeMatcher = DATETIME.matcher(body);\n            return dateTimeMatcher.find();\n        }\n    }\n\n    private void addSubstitutors() {\n        mSubstitutorList = new ArrayList<>();\n        mSubstitutorList.add(new DateTimeSubstitutor());\n        mSubstitutorList.add(new DateSubstitutor());\n        mSubstitutorList.add(new ParameterSubstitutor());\n    }\n\n}\n"}},"public":false,"created_at":"2017-03-09T11:13:56Z","updated_at":"2017-03-09T11:13:56Z","description":"An OkHttp Interceptor that returns mocked results if it has them.","comments":0,"user":null,"comments_url":"https://api.github.com/gists/19c6aadff4c74dbeb108ec21003c7822/comments","forks":[],"history":[{"user":{"login":"invalid-email-address","id":148100,"avatar_url":"https://avatars3.githubusercontent.com/u/148100?v=3","gravatar_id":"","url":"https://api.github.com/users/invalid-email-address","html_url":"https://github.com/invalid-email-address","followers_url":"https://api.github.com/users/invalid-email-address/followers","following_url":"https://api.github.com/users/invalid-email-address/following{/other_user}","gists_url":"https://api.github.com/users/invalid-email-address/gists{/gist_id}","starred_url":"https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/invalid-email-address/subscriptions","organizations_url":"https://api.github.com/users/invalid-email-address/orgs","repos_url":"https://api.github.com/users/invalid-email-address/repos","events_url":"https://api.github.com/users/invalid-email-address/events{/privacy}","received_events_url":"https://api.github.com/users/invalid-email-address/received_events","type":"User","site_admin":false},"version":"2b40c6f4ddd97682eb26b4a24fd1da760bb88fe9","committed_at":"2017-03-09T11:13:56Z","change_status":{"total":553,"additions":553,"deletions":0},"url":"https://api.github.com/gists/19c6aadff4c74dbeb108ec21003c7822/2b40c6f4ddd97682eb26b4a24fd1da760bb88fe9"}],"truncated":false}
